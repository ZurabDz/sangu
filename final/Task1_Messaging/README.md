# Task 1: Encrypted Messaging App Prototype - Encryption Flow

This prototype demonstrates a hybrid encryption system using RSA and AES-GCM to securely send a message from User B to User A.

## Steps:

1.  **User A: Key Generation**
    *   User A generates a 2048-bit RSA key pair (a private key and a public key).
    *   User A keeps the private key secret.
    *   User A shares the public key with User B (or makes it publicly available).

2.  **User B: Encryption Process**
    *   User B wants to send a secret message (`message.txt`).
    *   **AES Key Generation:** User B generates a cryptographically secure random 256-bit (32-byte) key for AES encryption.
    *   **Message Encryption (AES):**
        *   User B generates a random 12-byte Initialization Vector (IV or nonce).
        *   User B encrypts the secret message using AES-256 in GCM (Galois/Counter Mode). GCM provides both confidentiality (encryption) and authenticity/integrity (via an authentication tag).
        *   The output includes the IV, the ciphertext, and the authentication tag. These are combined and saved as `encrypted_message.bin`.
    *   **AES Key Encryption (RSA):**
        *   To securely send the AES key to User A, User B encrypts the *AES key itself* using User A's *public RSA key*.
        *   RSA encryption uses OAEP padding for security.
        *   The encrypted AES key is saved as `aes_key_encrypted.bin`.
    *   User B sends `encrypted_message.bin` and `aes_key_encrypted.bin` to User A.

3.  **User A: Decryption Process**
    *   User A receives the two files from User B.
    *   **AES Key Decryption (RSA):**
        *   User A uses their *private RSA key* to decrypt `aes_key_encrypted.bin`. This recovers the original AES key generated by User B.
    *   **Message Decryption (AES):**
        *   User A parses `encrypted_message.bin` to extract the IV, authentication tag, and ciphertext.
        *   User A uses the *decrypted AES key* and the extracted IV to decrypt the ciphertext using AES-256-GCM.
        *   During decryption, GCM automatically verifies the authentication tag. If the tag is valid (meaning the ciphertext wasn't tampered with), decryption succeeds. Otherwise, it fails.
        *   The successfully decrypted plaintext is saved to `decrypted_message.txt`.

## Why Hybrid Encryption?

*   **AES:** Fast and efficient for encrypting large amounts of data (the message).
*   **RSA:** Slower, but suitable for encrypting small amounts of data (the AES key) and key exchange using public-key infrastructure.
*   Combining them leverages the strengths of both: the speed of symmetric encryption for the bulk data and the convenience of asymmetric encryption for secure key exchange.